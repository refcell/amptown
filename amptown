#!/usr/bin/env bash
#
# amptown - Multi-agent gastown orchestrator
#
# Spawns 6 gastown instances for autonomous repository development:
#   - 3 Reviewers: Monitor PRs, deliberate on merging, provide feedback
#   - 3 Implementers: Write code and documentation
#
# Usage: amptown [OPTIONS] <repo-path>
#

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_NAME="amptown"
AGENT_BACKEND="amp"
INSTANCE_ID=""  # Unique ID for this amptown instance
TMUX_SESSION_PREFIX="amptown"
LOG_DIR=""
REPO_PATH=""
TOWN_PATH=""
INSTRUCTIONS_FILE=""
INSTRUCTIONS_TEXT=""
REVIEWER_INSTRUCTIONS=""
IMPLEMENTER_INSTRUCTIONS=""

# Agent definitions
declare -a REVIEWER_NAMES=("reviewer-alpha" "reviewer-beta" "reviewer-gamma")
declare -a IMPLEMENTER_NAMES=("impl-alpha" "impl-beta" "impl-gamma")

# Agent roles with their instructions
REVIEWER_ROLE="You are a code reviewer. Monitor this repository for pull requests. 
Review PRs thoroughly, provide constructive feedback, and approve when ready.

BEFORE MERGING ANY PR, you MUST:
1. Check ALL review comments - ensure every comment thread is resolved or addressed
2. Check if any reviewer requested changes or left blocking feedback
3. Verify the PR is approved (not just commented on)
4. Check CI/build status - all checks must pass
5. Look for any 'changes requested' reviews that haven't been re-approved
6. If another agent closed the PR or requested changes, DO NOT merge - respect their decision

Only merge when: all comments are resolved, at least one approval exists, no unresolved change requests, and CI is green.
If any of these conditions are not met, leave a comment explaining what's blocking the merge.

Focus on: code quality, security, testing, documentation, and best practices.
Coordinate with other reviewers to avoid duplicate work."

IMPLEMENTER_ROLE="You are a code implementer. Build features, fix bugs, and write documentation.
Create PRs for your changes. Follow the project's coding standards.
Focus on: clean code, comprehensive tests, clear documentation, and small focused PRs.
Coordinate with other implementers to avoid conflicts."

# Logging functions
log_info() { echo -e "${BLUE}[INFO]${NC} $*"; }
log_success() { echo -e "${GREEN}[OK]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*" >&2; }
log_header() { echo -e "\n${BOLD}${CYAN}=== $* ===${NC}\n"; }

# Print usage
usage() {
    cat << EOF
${BOLD}amptown${NC} - Multi-agent gastown orchestrator

${BOLD}USAGE:${NC}
    $SCRIPT_NAME [OPTIONS] <repo-path>
    $SCRIPT_NAME <command>

${BOLD}COMMANDS:${NC}
    down              Stop all amptown agents and clean up temp files
    status            Show status of running agents
    clean             Clean up stale temp directories (without stopping agents)
    monitor           Live monitor of agent status

${BOLD}DESCRIPTION:${NC}
    Spawns 6 amp agents to autonomously develop a repository:
    
    ${CYAN}Reviewers (3):${NC}  reviewer-alpha, reviewer-beta, reviewer-gamma
    ${CYAN}Implementers (3):${NC}  impl-alpha, impl-beta, impl-gamma

${BOLD}OPTIONS:${NC}
    -h, --help          Show this help message
    -t, --town PATH     Use existing gastown town directory
    -l, --logs PATH     Directory for agent logs
    -i, --instructions FILE   Instructions file for all agents
    -p, --prompt TEXT   Instructions text for all agents (inline)
    --instance ID       Use specific instance ID (auto-generated from repo path if not set)
    --dry-run           Show what would be done without executing

${BOLD}EXAMPLES:${NC}
    $SCRIPT_NAME ~/projects/myrepo    # Start agents
    $SCRIPT_NAME -p "Focus on the devnet" ~/projects/myrepo
    $SCRIPT_NAME status               # Check status
    $SCRIPT_NAME down                 # Stop all agents and clean up
    $SCRIPT_NAME clean                # Clean stale temp dirs only

${BOLD}REQUIREMENTS:${NC}
    - gastown (gt) installed and in PATH
    - amp CLI installed and in PATH
    - tmux installed
    - git repository at <repo-path>

EOF
    exit 0
}

# Check if a command exists
check_command() {
    local cmd="$1"
    local install_hint="${2:-}"
    
    if ! command -v "$cmd" &> /dev/null; then
        log_error "'$cmd' is not installed or not in PATH"
        if [[ -n "$install_hint" ]]; then
            log_error "Install with: $install_hint"
        fi
        return 1
    fi
    return 0
}

# Verify all prerequisites
check_prerequisites() {
    log_header "Checking Prerequisites"
    
    local failed=0
    
    # Check gastown
    if ! check_command "gt" "brew install gastown OR npm install -g @gastown/gt OR go install github.com/steveyegge/gastown/cmd/gt@latest"; then
        failed=1
    else
        log_success "gastown (gt) found: $(command -v gt)"
    fi
    
    # Check amp
    if ! check_command "amp" "Visit https://ampcode.com for installation instructions"; then
        failed=1
    else
        log_success "amp found: $(command -v amp)"
    fi
    
    # Check tmux
    if ! check_command "tmux" "brew install tmux OR apt install tmux"; then
        failed=1
    else
        log_success "tmux found: $(command -v tmux)"
    fi
    
    # Check git
    if ! check_command "git" "brew install git OR apt install git"; then
        failed=1
    else
        log_success "git found: $(command -v git)"
    fi
    
    if [[ $failed -eq 1 ]]; then
        log_error "Missing prerequisites. Please install them and try again."
        exit 1
    fi
    
    log_success "All prerequisites satisfied"
}

# Validate repository path
validate_repo() {
    local repo="$1"
    
    if [[ ! -d "$repo" ]]; then
        log_error "Repository path does not exist: $repo"
        exit 1
    fi
    
    if [[ ! -d "$repo/.git" ]]; then
        log_error "Not a git repository: $repo"
        exit 1
    fi
    
    log_success "Valid git repository: $repo"
}

# Create or validate town directory
setup_town() {
    if [[ -z "$TOWN_PATH" ]]; then
        TOWN_PATH=$(mktemp -d "${TMPDIR:-/tmp}/amptown-XXXXXX")
        log_info "Created temporary town: $TOWN_PATH"
    fi
    
    # Initialize gastown if needed
    if [[ ! -f "$TOWN_PATH/.gt-town" ]] && [[ ! -f "$TOWN_PATH/settings/config.json" ]]; then
        log_info "Initializing gastown town at $TOWN_PATH"
        gt install "$TOWN_PATH" --git 2>/dev/null || {
            # Try without --git flag if it fails
            gt install "$TOWN_PATH" 2>/dev/null || true
        }
    fi
    
    LOG_DIR="${LOG_DIR:-$TOWN_PATH/logs}"
    mkdir -p "$LOG_DIR"
    
    log_success "Town directory ready: $TOWN_PATH"
}

# Add the repository as a rig
setup_rig() {
    local repo_name
    repo_name=$(basename "$REPO_PATH")
    
    log_info "Setting up rig for $repo_name"
    
    cd "$TOWN_PATH"
    
    # Check if rig already exists
    if gt rig list 2>/dev/null | grep -q "$repo_name"; then
        log_info "Rig '$repo_name' already exists"
    else
        # Add the rig - use local path
        gt rig add "$repo_name" "$REPO_PATH" 2>/dev/null || {
            log_warn "Could not add rig via gt, will use direct approach"
        }
    fi
    
    echo "$repo_name"
}

# Generate unique instance ID based on repo path
generate_instance_id() {
    local repo="$1"
    # Create a short hash from the repo path for uniqueness
    # Works on both Linux (md5sum) and macOS (md5)
    if command -v md5sum &>/dev/null; then
        echo "$repo" | md5sum | cut -c1-8
    else
        echo "$repo" | md5 | cut -c1-8
    fi
}

# Generate unique session name (includes instance ID for isolation)
get_session_name() {
    local agent_name="$1"
    echo "${TMUX_SESSION_PREFIX}-${INSTANCE_ID}-${agent_name}"
}

# Check if a tmux session exists
session_exists() {
    local session="$1"
    tmux has-session -t "$session" 2>/dev/null
}

# Create agent instruction file
create_agent_instructions() {
    local agent_name="$1"
    local agent_type="$2"  # "reviewer" or "implementer"
    local instructions_file="$LOG_DIR/${agent_name}-instructions.md"
    
    local role_text
    if [[ "$agent_type" == "reviewer" ]]; then
        role_text="$REVIEWER_ROLE"
    else
        role_text="$IMPLEMENTER_ROLE"
    fi
    
    cat > "$instructions_file" << EOF
# Agent: $agent_name

## Role
$role_text

## Repository
Working on: $REPO_PATH

## Coordination
- Other ${agent_type}s are working in parallel
- Check for existing PRs before starting new work
- Communicate status via git commits and PR comments
- Avoid modifying the same files as other agents

## Getting Started
1. Explore the repository structure
2. Check existing issues and PRs
3. Identify work that needs to be done
4. Start with small, focused changes
EOF
    
    echo "$instructions_file"
}

# Spawn a single agent
spawn_agent() {
    local agent_name="$1"
    local agent_type="$2"
    local session_name
    session_name=$(get_session_name "$agent_name")
    
    if session_exists "$session_name"; then
        log_warn "Session $session_name already exists, skipping"
        return 0
    fi
    
    local log_file="$LOG_DIR/${agent_name}.log"
    local prompt_file="$LOG_DIR/${agent_name}-prompt.txt"
    
    log_info "Spawning $agent_type: $agent_name"
    
    # Write the prompt to a file to avoid shell escaping issues
    # Include handoff instructions to prevent context overflow
    local handoff_instructions="

CRITICAL: Context Management
You MUST use the 'handoff' tool to continue work in a new thread when:
- You have completed a significant task or milestone
- You notice responses getting slower or context feeling constrained
- After every 3-5 substantial operations (file edits, PR reviews, etc.)

When handing off, set follow=true and describe what work should continue.
This ensures continuous operation without context overflow."

    # Build custom instructions from file or text
    local custom_instructions=""
    if [[ -n "$INSTRUCTIONS_TEXT" ]]; then
        custom_instructions="

FOCUS AREA:
$INSTRUCTIONS_TEXT"
    elif [[ -n "$INSTRUCTIONS_FILE" ]] && [[ -f "$INSTRUCTIONS_FILE" ]]; then
        custom_instructions="

FOCUS AREA:
$(cat "$INSTRUCTIONS_FILE")"
    fi

    if [[ "$agent_type" == "reviewer" ]]; then
        cat > "$prompt_file" << EOF
You are $agent_name, a STRICT code reviewer for this repository. You have HIGH STANDARDS.

Your job:
1. Monitor PRs with 'gh pr list'
2. Review code THOROUGHLY - read every line
3. REJECT anything that doesn't meet quality standards
4. Only approve excellent code

BE STUBBORN. Reject PRs for ANY of these reasons:
- Code doesn't match existing repo style/patterns/conventions
- Uses wrong dependencies or adds unnecessary ones
- Just adds tests without real functionality
- Documentation-only changes that don't add value
- Doesn't follow the architecture of the codebase
- Low-effort or boilerplate code
- Changes that don't align with the project's purpose

Before merging, you MUST:
1. gh pr checkout <number>
2. Read the actual code changes carefully
3. Compare style to existing code in the repo
4. Run: cargo test && cargo clippy
5. gh pr checks <number> (all must pass)

If code doesn't meet standards:
  gh pr review <number> --request-changes --body "Reason for rejection"

Only if code is EXCELLENT:
  gh pr review <number> --approve
  gh pr merge <number> --squash --delete-branch

Be the gatekeeper. Bad code should NOT land. Request changes liberally.
${custom_instructions}
${handoff_instructions}

Start by checking 'gh pr list' and reviewing any open PRs with extreme scrutiny.
EOF
    else
        cat > "$prompt_file" << EOF
You are $agent_name, a code implementer for this repository.

RULES:
1. Study the codebase FIRST - understand style, patterns, architecture
2. Focus on core functionality that advances the project's purpose
3. Match existing code style (formatting, naming, structure)
4. Use ONLY dependencies already in the project
5. Prefer real features over tests-only or docs-only PRs

WORKFLOW - Submit PRs early and often:
1. Make a small, focused change (prefer <100 lines when possible)
2. Verify it compiles and passes tests
3. Submit PR immediately - don't batch multiple features
4. Move on to the next small improvement

Before writing code:
1. Quickly scan README and key source files
2. Check existing dependencies
3. Understand the immediate area you're changing

After making changes:
1. git checkout -b $agent_name/<short-description>
2. git add -A && git commit -m "type: description"
3. git push -u origin HEAD
4. gh pr create --title "type: description" --body "Brief explanation"

Keep PRs small and focused. One logical change per PR.
Submit frequently - don't wait for perfection.
${custom_instructions}
${handoff_instructions}

Start by exploring the codebase, then make your first small improvement.
EOF
    fi
    
    # Create a launcher script that runs amp in a loop
    # When amp exits (naturally or via timeout), restart with continuation prompt
    local launcher="$LOG_DIR/${agent_name}-launcher.sh"
    cat > "$launcher" << 'LAUNCHER'
#!/usr/bin/env bash
set -u
PROMPT_FILE="$1"
LOG_FILE="$2"
AGENT_NAME="$3"

initial_prompt=$(cat "$PROMPT_FILE")
iteration=0

while true; do
    iteration=$((iteration + 1))
    echo "[$(date)] Starting $AGENT_NAME iteration $iteration" >> "$LOG_FILE"
    
    if [[ $iteration -eq 1 ]]; then
        prompt="$initial_prompt"
    else
        prompt="You are $AGENT_NAME continuing your work in a fresh thread. Your previous thread likely hit the context limit. Use find_thread to locate your recent work, review what was done, and continue where you left off. Remember to use handoff with follow=true before context fills again."
    fi
    
    # Run amp and log output
    amp --dangerously-allow-all --no-ide --execute "$prompt" 2>&1 | tee -a "$LOG_FILE"
    exit_code=$?
    
    echo "[$(date)] $AGENT_NAME iteration $iteration ended (exit code: $exit_code)" >> "$LOG_FILE"
    
    # Brief pause before restarting
    sleep 5
done
LAUNCHER
    chmod +x "$launcher"
    
    # Create tmux session running the launcher
    tmux new-session -d -s "$session_name" -c "$REPO_PATH" \
        "$launcher '$prompt_file' '$log_file' '$agent_name'"
    
    log_success "Started $agent_name (session: $session_name, log: $log_file)"
}

# Spawn all agents
spawn_all_agents() {
    log_header "Spawning Reviewers"
    for name in "${REVIEWER_NAMES[@]}"; do
        spawn_agent "$name" "reviewer"
        sleep 2  # Stagger spawns to avoid rate limits
    done
    
    log_header "Spawning Implementers"
    for name in "${IMPLEMENTER_NAMES[@]}"; do
        spawn_agent "$name" "implementer"
        sleep 2
    done
}

# Show status of all agents (for a specific instance or all instances)
show_status() {
    log_header "Agent Status"
    
    local found=0
    
    # If we have an instance ID, show status for that instance only
    if [[ -n "$INSTANCE_ID" ]]; then
        echo -e "${BOLD}Instance:${NC} $INSTANCE_ID"
        echo ""
        echo -e "${BOLD}Reviewers:${NC}"
        for name in "${REVIEWER_NAMES[@]}"; do
            local session_name
            session_name=$(get_session_name "$name")
            if session_exists "$session_name"; then
                echo -e "  ${GREEN}●${NC} $name (session: $session_name)"
                found=1
            else
                echo -e "  ${RED}○${NC} $name (not running)"
            fi
        done
        
        echo ""
        echo -e "${BOLD}Implementers:${NC}"
        for name in "${IMPLEMENTER_NAMES[@]}"; do
            local session_name
            session_name=$(get_session_name "$name")
            if session_exists "$session_name"; then
                echo -e "  ${GREEN}●${NC} $name (session: $session_name)"
                found=1
            else
                echo -e "  ${RED}○${NC} $name (not running)"
            fi
        done
    else
        # No instance ID - show all running amptown sessions
        echo -e "${BOLD}All running amptown sessions:${NC}"
        local sessions
        sessions=$(tmux list-sessions 2>/dev/null | grep "^${TMUX_SESSION_PREFIX}-" || true)
        if [[ -n "$sessions" ]]; then
            echo "$sessions" | while read -r line; do
                echo -e "  ${GREEN}●${NC} $line"
            done
            found=1
        fi
    fi
    
    if [[ $found -eq 0 ]]; then
        echo ""
        log_info "No agents are currently running"
    else
        echo ""
        echo -e "${BOLD}Commands:${NC}"
        echo "  Attach to agent:  tmux attach -t <session-name>"
        echo "  View all:         tmux list-sessions | grep ${TMUX_SESSION_PREFIX}"
        echo "  Stop all:         $SCRIPT_NAME down <repo-path>"
        echo "  Stop specific:    $SCRIPT_NAME down --instance <instance-id>"
    fi
}

# Find all amptown temp directories
find_amptown_dirs() {
    local dirs=()
    
    # Check TMPDIR (macOS primary location)
    if [[ -n "${TMPDIR:-}" ]]; then
        local tmpdir="${TMPDIR%/}"
        while IFS= read -r -d '' dir; do
            dirs+=("$dir")
        done < <(find "$tmpdir" -maxdepth 1 -type d -name "amptown-*" -print0 2>/dev/null || true)
    fi
    
    # Check /tmp
    while IFS= read -r -d '' dir; do
        dirs+=("$dir")
    done < <(find /tmp -maxdepth 1 -type d -name "amptown-*" -print0 2>/dev/null || true)
    
    # Check /var/folders (macOS)
    if [[ -d /var/folders ]]; then
        while IFS= read -r -d '' dir; do
            dirs+=("$dir")
        done < <(find /var/folders -type d -name "amptown-*" -print0 2>/dev/null || true)
    fi
    
    # Remove duplicates
    printf '%s\n' "${dirs[@]}" | sort -u
}

# Clean up temporary directories for an instance or all instances
cleanup_temp_dirs() {
    local cleaned=0
    local freed_bytes=0
    
    log_info "Cleaning up temporary directories..."
    
    while IFS= read -r dir; do
        [[ -z "$dir" ]] && continue
        
        # Extract instance ID from directory name
        local dir_name
        dir_name=$(basename "$dir")
        local dir_instance_id="${dir_name#amptown-}"
        
        # If we have a specific instance ID, only clean that one
        if [[ -n "$INSTANCE_ID" && "$dir_instance_id" != "$INSTANCE_ID" ]]; then
            continue
        fi
        
        # Check if any sessions are still running for this instance
        local still_running=false
        if tmux list-sessions -F "#{session_name}" 2>/dev/null | grep -q "^${TMUX_SESSION_PREFIX}-${dir_instance_id}-"; then
            still_running=true
        fi
        
        if [[ "$still_running" == true ]]; then
            log_warn "Skipping $dir (sessions still running)"
            continue
        fi
        
        # Calculate size before deletion
        local size
        size=$(du -sk "$dir" 2>/dev/null | cut -f1 || echo 0)
        freed_bytes=$((freed_bytes + size))
        
        # Remove the directory
        if rm -rf "$dir" 2>/dev/null; then
            log_info "Removed: $dir (${size}KB)"
            cleaned=$((cleaned + 1))
        else
            log_warn "Failed to remove: $dir"
        fi
    done < <(find_amptown_dirs)
    
    if [[ $cleaned -eq 0 ]]; then
        log_info "No temporary directories to clean"
    else
        local freed_mb=$((freed_bytes / 1024))
        if [[ $freed_mb -gt 0 ]]; then
            log_success "Cleaned $cleaned directories, freed ${freed_mb}MB"
        else
            log_success "Cleaned $cleaned directories, freed ${freed_bytes}KB"
        fi
    fi
}

# Stop all agents for a specific instance or all instances
stop_all_agents() {
    log_header "Stopping Agents"
    
    local stopped=0
    
    if [[ -n "$INSTANCE_ID" ]]; then
        # Stop agents for specific instance
        log_info "Stopping instance: $INSTANCE_ID"
        for name in "${REVIEWER_NAMES[@]}" "${IMPLEMENTER_NAMES[@]}"; do
            local session_name
            session_name=$(get_session_name "$name")
            if session_exists "$session_name"; then
                log_info "Stopping $name..."
                tmux kill-session -t "$session_name" 2>/dev/null || true
                stopped=$((stopped + 1))
            fi
        done
    else
        # Stop all amptown sessions
        log_info "Stopping all amptown instances"
        local sessions
        sessions=$(tmux list-sessions -F "#{session_name}" 2>/dev/null | grep "^${TMUX_SESSION_PREFIX}-" || true)
        for session in $sessions; do
            log_info "Stopping session: $session"
            tmux kill-session -t "$session" 2>/dev/null || true
            stopped=$((stopped + 1))
        done
    fi
    
    if [[ $stopped -eq 0 ]]; then
        log_info "No agents were running"
    else
        log_success "Stopped $stopped agents"
    fi
    
    # Clean up temporary directories
    log_header "Cleaning Up"
    cleanup_temp_dirs
}

# Monitor agents
monitor_agents() {
    log_header "Monitoring Agents"
    log_info "Press Ctrl+C to exit monitoring"
    echo ""
    
    while true; do
        clear
        echo -e "${BOLD}${CYAN}=== AMPTOWN Monitor ===${NC}"
        echo -e "Repository: $REPO_PATH"
        echo -e "Time: $(date '+%Y-%m-%d %H:%M:%S')"
        echo ""
        
        show_status
        
        sleep 5
    done
}

# Main function
main() {
    local dry_run=false
    local action="start"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                ;;
            -t|--town)
                TOWN_PATH="$2"
                shift 2
                ;;
            -l|--logs)
                LOG_DIR="$2"
                shift 2
                ;;
            -i|--instructions)
                INSTRUCTIONS_FILE="$2"
                shift 2
                ;;
            -p|--prompt)
                INSTRUCTIONS_TEXT="$2"
                shift 2
                ;;
            --reviewer-instructions)
                REVIEWER_INSTRUCTIONS="$2"
                shift 2
                ;;
            --implementer-instructions)
                IMPLEMENTER_INSTRUCTIONS="$2"
                shift 2
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --instance)
                INSTANCE_ID="$2"
                shift 2
                ;;
            --stop|down)
                action="stop"
                shift
                ;;
            --status|status)
                action="status"
                shift
                ;;
            --clean|clean)
                action="clean"
                shift
                ;;
            --monitor|monitor)
                action="monitor"
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                echo "Use '$SCRIPT_NAME --help' for usage"
                exit 1
                ;;
            *)
                REPO_PATH="$1"
                shift
                ;;
        esac
    done
    
    # Generate instance ID from repo path if provided and not already set
    if [[ -n "$REPO_PATH" && -z "$INSTANCE_ID" ]]; then
        REPO_PATH=$(cd "$REPO_PATH" && pwd)
        INSTANCE_ID=$(generate_instance_id "$REPO_PATH")
    fi
    
    # Handle status/stop without repo path
    if [[ "$action" == "status" ]]; then
        show_status
        exit 0
    fi
    
    if [[ "$action" == "stop" ]]; then
        stop_all_agents
        exit 0
    fi
    
    if [[ "$action" == "clean" ]]; then
        log_header "Cleaning Up Stale Directories"
        cleanup_temp_dirs
        exit 0
    fi
    
    # For start/monitor, we need repo path
    if [[ -z "$REPO_PATH" ]]; then
        log_error "Repository path required"
        echo "Use '$SCRIPT_NAME --help' for usage"
        exit 1
    fi
    
    # Run startup sequence
    check_prerequisites
    validate_repo "$REPO_PATH"
    
    if [[ "$dry_run" == true ]]; then
        log_header "Dry Run - Would Execute"
        echo "Repository: $REPO_PATH"
        echo "Instance ID: $INSTANCE_ID"
        echo "Town: ${TOWN_PATH:-<auto-generated>}"
        echo ""
        echo "Would spawn:"
        echo "  Reviewers: ${REVIEWER_NAMES[*]}"
        echo "  Implementers: ${IMPLEMENTER_NAMES[*]}"
        exit 0
    fi
    
    setup_town
    
    log_header "Starting AMPTOWN"
    echo -e "Repository: ${CYAN}$REPO_PATH${NC}"
    echo -e "Instance ID: ${CYAN}$INSTANCE_ID${NC}"
    echo -e "Town: ${CYAN}$TOWN_PATH${NC}"
    echo -e "Logs: ${CYAN}$LOG_DIR${NC}"
    echo ""
    
    spawn_all_agents
    
    log_header "AMPTOWN is Running"
    echo -e "${GREEN}All 6 agents have been spawned!${NC}"
    echo ""
    echo -e "${BOLD}Instance ID:${NC} $INSTANCE_ID"
    echo -e "${BOLD}Reviewers:${NC} ${REVIEWER_NAMES[*]}"
    echo -e "${BOLD}Implementers:${NC} ${IMPLEMENTER_NAMES[*]}"
    echo ""
    echo -e "${BOLD}Useful commands:${NC}"
    echo "  View status:      $SCRIPT_NAME status $REPO_PATH"
    echo "  Stop this:        $SCRIPT_NAME down $REPO_PATH"
    echo "  Stop all:         $SCRIPT_NAME down"
    echo "  Attach to agent:  tmux attach -t ${TMUX_SESSION_PREFIX}-${INSTANCE_ID}-<agent-name>"
    echo "  View logs:        tail -f $LOG_DIR/<agent-name>.log"
    echo ""
    
    if [[ "$action" == "monitor" ]]; then
        monitor_agents
    fi
}

main "$@"
